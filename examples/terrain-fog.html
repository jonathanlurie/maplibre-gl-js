<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display a map</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <script src="../dist/maplibre-gl-dev.js"></script>
    <link href="../dist/maplibre-gl.css" rel="stylesheet" />
    <style>
      body { margin: 0; padding: 0; }
      #map { position: absolute; top: 0; bottom: 0; width: 100%; }
      #debug-img {
        z-index: 1;
        position: absolute;
        pointer-events: none;
        /* opacity: 0.3; */
        transform: scale(1, -1);
      }

      #control-panel {
        position: absolute;
        background: #ffffffd6;
        width: fit-content;
        height: fit-content;
        z-index: 1;
        padding: 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="debug-img" ></canvas>
    <div id="map"></div>

    <div id="control-panel">
      <div>
        <input type="checkbox" id="debugOverlay" name="debugOverlay" checked>
        <label for="debugOverlay">Debug overlay</label>
      </div>

      <div>
        <input type="range" id="canvasOpacity" name="canvasOpacity" min="0" max="1" step="0.01" value="1">
        <label for="canvasOpacity">Overlay opacity</label>
      </div>

    </div>
    <script>

    function unpack(value) {
      const bitSh = [1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0];
      let result = 0.0;
      for (let i = 0; i < 4; i++) {
        result += value[i] * bitSh[i];
      }
      return result;
    }

    let useDebugOverlay = true;

    document.getElementById("debugOverlay").addEventListener("change", (evt) => {
      useDebugOverlay = evt.target.checked;
      map.painter.terrainFacilitator.dirty = true;
      map.triggerRepaint()
      // map.redraw()
    })


    document.getElementById("canvasOpacity").addEventListener("input", (evt) => {
      canvas.style.opacity = parseFloat(evt.target.value);
    })

    


    window.debug = true
    window.mapPitch = 0;

    const apiKey = "n3xWyMyvvvh0po45JG2D";


    // https://www.maptiler.com/maps/#style=nl-cartiqo-light&position=12.16/52.05213/5.08867


    const map = new maplibregl.Map({
      container: 'map', // container id
      hash: true,
      maxPitch: 85,
      style: `https://api.maptiler.com/maps/outdoor-v2/style.json?key=${apiKey}`,
      center: [0, 0], // starting position [lng, lat]
      zoom: 1 // starting zoom
    });

    console.log(map);


    map.on("load", () => {
      addTerrain();
      window.mapPitch = map.getPitch();
    })

    map.on("pitch", (evt) => {
      window.mapPitch = map.getPitch();
    })

    function addTerrain() {
      map.addSource("terrain-source", {
        type: "raster-dem",
        url: `https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=${apiKey}`,
      });

      map.setTerrain({
        source: "terrain-source",
        exaggeration: 1.5,
      });
    }

    const canvas = document.getElementById('debug-img');

    map.painter.on("postDrawDepth", (evt) => {
      const { painter, gl, terrain } = evt

      // Get the viewport size, which is going to be size of the texture
      const viewportPixelSize = [painter.width  / devicePixelRatio, painter.height / devicePixelRatio];

      // creating an array to store the 2D image of the texture.
      const pixels = new Uint8Array(viewportPixelSize[0] * viewportPixelSize[1] * 4);

      // Getting the pixels from the viewport
      gl.readPixels(0, 0, viewportPixelSize[0], viewportPixelSize[1], gl.RGBA, gl.UNSIGNED_BYTE, pixels);
      
      canvas.width = viewportPixelSize[0];
      canvas.height = viewportPixelSize[1];
      const ctx = canvas.getContext("2d");
      const canvasImageData = ctx.getImageData(0, 0, viewportPixelSize[0], viewportPixelSize[1]);
      const canvasImageDataArray = canvasImageData.data;
      const nbPixels = viewportPixelSize[0] * viewportPixelSize[1];

      const floatDepth = new Float32Array(nbPixels);

      let minDepth = +Infinity;
      let maxDepth = -Infinity;

      // For each pixel of the canvas
      for (let i = 0; i < nbPixels; i += 1) {
        let depthValue = unpack([
          pixels[i*4],
          pixels[i*4 + 1],
          pixels[i*4 + 2],
          pixels[i*4 + 3],
        ])

        if (depthValue === 0) {
          depthValue = 255;
        }

        floatDepth[i] = depthValue;
        minDepth = Math.min(minDepth, depthValue);
        maxDepth = Math.max(maxDepth, depthValue);

        // value is no ~linear in [0, 255]
        // 0 being the closest
        // 255 being the furthest
        const remappedDepth = (depthValue - 240) * 17
        
        const naturalPhogDepth = (remappedDepth - 100) * 1.67;
        const pitchFactor = window.mapPitch < 60 ? 0 : (window.mapPitch - 60) / 20; 

        if (useDebugOverlay) {
          // debug mode
          canvasImageDataArray[i*4] = naturalPhogDepth * pitchFactor;
          canvasImageDataArray[i*4 + 1] = naturalPhogDepth * pitchFactor;
          canvasImageDataArray[i*4 + 2] = naturalPhogDepth * pitchFactor; 
          canvasImageDataArray[i*4 + 3] = 255;
        } else {
          // Haze effect
          canvasImageDataArray[i*4] = 255;
          canvasImageDataArray[i*4 + 1] = 255;
          canvasImageDataArray[i*4 + 2] = 255; 
          canvasImageDataArray[i*4 + 3] = naturalPhogDepth * pitchFactor; 
        }
      }
      ctx.putImageData(canvasImageData, 0, 0);
    })


    

    </script>
  
  </body>
</html>