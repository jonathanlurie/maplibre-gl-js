<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Display a map</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <script src="../dist/maplibre-gl-dev.js"></script>
    <link href="../dist/maplibre-gl.css" rel="stylesheet" />
    <style>
      body { margin: 0; padding: 0; }
      #map { position: absolute; top: 0; bottom: 0; width: 100%; }
      #debug-img {
        z-index: 1;
        position: absolute;
        pointer-events: none;
        /* opacity: 0.3; */
        transform: scale(1, -1);
        width: 100%;
      }

      #control-panel {
        position: absolute;
        background: #ffffffd6;
        width: fit-content;
        height: fit-content;
        z-index: 1;
        padding: 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="debug-img" ></canvas>
    <div id="map"></div>

    <div id="control-panel">
      <div>
      <div>
        <input type="range" id="canvasOpacity" name="canvasOpacity" min="0" max="1" step="0.01" value="1">
        <label for="canvasOpacity">Overlay opacity</label>
      </div>

      <div>
        <input type="range" id="brightness" name="brightness" min="-255" max="255" step="1" value="0">
        <label for="brightness">Brightness</label>
      </div>

      <div>
        <input type="range" id="contrast" name="contrast" min="-255" max="255" step="1" value="0">
        <label for="contrast">Contrast</label>
      </div>

    </div>
    <script>

    function unpack(value) {
      const bitSh = [1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0];
      let result = 0.0;
      for (let i = 0; i < 4; i++) {
        result += value[i] * bitSh[i];
      }
      return result;
    }

    document.getElementById("canvasOpacity").addEventListener("input", (evt) => {
      canvas.style.opacity = parseFloat(evt.target.value);
    })

    let minIntensity = 0
    let maxInsenity = 255

    let brightness = 0;

    document.getElementById("contrast").addEventListener("input", (evt) => {
      const contrastValue = parseFloat(evt.target.value);
      minIntensity = contrastValue / 2
      maxInsenity = 255 - minIntensity;
      map.painter.terrainFacilitator.dirty = true;
      map.triggerRepaint()
    })

    document.getElementById("brightness").addEventListener("input", (evt) => {
      brightness = parseFloat(evt.target.value);
      map.painter.terrainFacilitator.dirty = true;
      map.triggerRepaint()
    })

    


    window.debug = true
    window.mapPitch = 0;

    const apiKey = "n3xWyMyvvvh0po45JG2D";


    // https://www.maptiler.com/maps/#style=nl-cartiqo-light&position=12.16/52.05213/5.08867


    const map = new maplibregl.Map({
      container: 'map', // container id
      hash: true,
      maxPitch: 85,
      style: `https://api.maptiler.com/maps/outdoor-v2/style.json?key=${apiKey}`,
      center: [0, 0], // starting position [lng, lat]
      zoom: 1 // starting zoom
    });

    console.log(map);


    map.on("load", () => {
      addTerrain();
      window.mapPitch = map.getPitch();
    })

    map.on("pitch", (evt) => {
      window.mapPitch = map.getPitch();
    })

    function addTerrain() {
      map.addSource("terrain-source", {
        type: "raster-dem",
        url: `https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json?key=${apiKey}`,
      });

      map.setTerrain({
        source: "terrain-source",
        exaggeration: 1.5,
      });
    }

    const canvas = document.getElementById('debug-img');

    

    map.painter.on("postDrawTerrain", (evt) => {
      const { painter, gl, terrain } = evt

      // Get the viewport size, which is going to be size of the texture
      const viewportPixelSize = [painter.width, painter.height];

      // creating an array to store the 2D image of the texture.
      const pixels = new Uint8Array(viewportPixelSize[0] * viewportPixelSize[1] * 4);

      // Getting the pixels from the viewport
      gl.readPixels(0, 0, viewportPixelSize[0], viewportPixelSize[1], gl.RGBA, gl.UNSIGNED_BYTE, pixels);

      canvas.width = viewportPixelSize[0];
      canvas.height = viewportPixelSize[1];
      const ctx = canvas.getContext("2d");
      const canvasImageData = ctx.getImageData(0, 0, viewportPixelSize[0], viewportPixelSize[1]);
      const canvasImageDataArray = canvasImageData.data;
      const nbPixels = viewportPixelSize[0] * viewportPixelSize[1];


      for(let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        // gray=0.299red+0.587green+0.114blue 
        let  bwValue = 0.299 * r + 0.587 * g + 0.114 * b;
        bwValue = 255 * ((bwValue - minIntensity) / (maxInsenity - minIntensity)) + brightness;
        canvasImageDataArray[i] = bwValue
        canvasImageDataArray[i + 1] = bwValue
        canvasImageDataArray[i + 2] = bwValue
        canvasImageDataArray[i + 3] = pixels[i + 3];
      }

      // canvasImageDataArray.set(pixels);
      ctx.putImageData(canvasImageData, 0, 0);
    })


    

    </script>
  
  </body>
</html>